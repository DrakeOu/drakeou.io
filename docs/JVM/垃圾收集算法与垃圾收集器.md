# 垃圾收集算法与垃圾收集器



## 对象存活判断

### 引用计数法

对每个对象进行引用计数，实现简单，但无法解决循环依赖的问题。

### 可达性分析算法

通过一系列被称为`GC Roots`的对象作为起点，从这些节点开始向下搜索过的路径称为**引用链**。没有在**引用链**中的对象及不可达，会被标记成可回收。

#### GC ROOTS

包含如下几种：

1. 虚拟机栈中的对象（正在使用的对象）
2. 方法区中类静态属性引用的对象（`static`）
3. 方法区中常量引用的对象（`static final`）
4. 本地方法栈中JNI引用的对象

### 四种引用

这部分有点难以理解，后面找到例子再补上

## 收集算法

**按是否产生内存碎片和是否进行复制整理，可以分成下面三种算法**

**注意这个小节只讨论算法，不包含实现细节**

### 标记-清除(Mark-Sweep)

结合前面的可达性算法分析，这个算法分成**标记**和**清除**两个过程，标记是使用可达性算法标记可以回收对象，清除则直接将对象内存重新设定成可用。

此算法的主要问题在于：

1. 效率不高（？这点来自书上，还未求证）
2. 内存碎片，这将给尝试为大对象分配内存时带来不便，内存空间实际足够，但连续空间不够，会**提前触发另一次垃圾收集动作**

### 复制算法

> 适合对象存活率低，这样复制代价小，性能好，频繁触发GC考虑此算法，有空间浪费

相比上面的算法，这个算法效率更高。将内存分成两个区域，每次需要GC时将**存活的对象复制到另外一个区域并连续排列**。带来的优势是，不再有标记的需求（因为移动了存活的对象后，剩下的就是可用回收的对象），同时空出的区域称为了新的分配区域，没有内存碎片的问题。

这也是目前最常见的**用于新生代的回收算法**。如Hotspot虚拟机会按8：1分配Eden和两个Survivor区

### 标记-整理

> 性能差，没有空间浪费，无内存碎片

这个算法在清除回收对象后进行了对象向一端的移动，用以清除内存碎片。性能显然比标记-清除还要差，但适合收集对象大概率存活的情况。



## 垃圾收集器

### 概念

- `STW`：Stop the world，出于对**一致性**的要求，进行可达性算法分析时，**不得不暂停所有线程的允许以形成类似程序快照的局面**。
- `安全点`：选取基本按**程序是否具有长时间运行的特征**进行（循环，方法调用，异常跳转）。而这是对每个线程而言的，STW需要所有的线程运行到安全点，才会开始可达性分析。
- `安全区域`：和安全点对应，安全区域是确保**不在运行的线程的安全**，比如执行了`sleep`, `wait`方法的线程，并不能运行，那么会被标记成进入了`safe region`则JVM进行GC时不会处理安全区域的线程。

运行的线程到达安全点，不在运行的线程到达安全区，可以STW。

### 总览

按回收区域进行划分：

| 新生代            | 老年代       | 全年龄收集 |
| ----------------- | ------------ | ---------- |
| Serial            | Serial Old   | G1         |
| ParNew            | CMS          |            |
| Parallel Scavenge | Parallel Old |            |

按线程划分：

| 单线程     | 多线程            |
| ---------- | ----------------- |
| Serial     | ParNew            |
| Serial Old | Parallel Scavenge |
|            | Parallel Old      |
|            | CMS               |
|            | G1                |

按算法划分：

| 标记-清除 | 复制算法          | 标记-整理    |
| --------- | ----------------- | ------------ |
| CMS       | Serial            | Serial Old   |
|           | ParNew            | Parallel Old |
|           | Parallel Scavenge | G1           |



### Serial/Old收集器

> 什么是虚拟机的Client模式?

- 新生代使用**复制算法**
- 暂停所有线程
- 单线程，简单高效，没有线程切换开销
- 虚拟机Client模式下的**默认新生代/老年代收集器**

### ParNew收集器

- Serial的多线程版本，同样使用复制算法
- 可以配合CMS收集器，进行对应新生代的多线程收集
- 适合多核的Server模式

### Parallel Scavenge收集器

- 注重吞吐量（运行用户代码时间/（运行用户代码时间+垃圾收集时间））的收集器，
- 同样使用复制算法
- 提供针对吞吐量的控制参数，**最大垃圾收集停顿时间，-XX:MaxGCPauseMills**和**吞吐量大小，-XX:GCTimeRatio**
- 有自适应调节策略，**-XX:+UseAdaptiveSizePolicy**可以动态调节适合的最大停顿时间以及吞吐量
- 只能和`Parallel Old`配合工作

### CMS收集器

`Concurrent Mark Sweep`表明这是一种使用**标记-清除**算法的收集器，工作过程如下：

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

其中标记步骤1，3是STW的，初始标记仅简单标记`GC Roots`可达对象，速度很快，重新标记则是为作后清除时建立**一致性**，所以需要STW；运行时间最长的并发标记及并发清除都是和用户线程并发执行。

有如下缺点：

1. CPU敏感，并发影响用户线程
2. 并发清除的过程可能产生标记之外的垃圾，**浮动垃圾**无法清除，而导致GC一次后仍有垃圾。且因为GC的流程较长，不能等老年代完全分配完再GC，一般会提前GC。
3. 标记-清除的算法缺陷，内存碎片

### G1收集器

G1指`Garbage-First`，每次在允许的时间内优先收集价值最大的`Region`，而`Region`同时也表明了在G1收集器的划分下，内存布局和其他收集器不同，将内存划分成一个个`Region`，而根据`Region`的价值维护一个**优先队列**。

其使用的是**标记-整理**算法，相比CMS，没有内存碎片的问题，同时保留了分代的概念，一个收集器对不同代使用不同的算法。且它也算一款并发收集器，STW时间短，并建立了**可预测的停顿模型**。

运行流程大致如下：

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收



