## JMM & Volatile

>  Jmm是什么

JMM是Java内存模型，是一种内存的操作约定。用于在内存中划分操作



JMM规定了3块区域：

- 工作内存
- 主存
- 计算引擎

JMM规定了一些同步约定（针对加锁解锁的规定）：

- 加锁前必须从主存中读取最新值
- 解锁必须将工作内存中值写到主存
- 加锁解锁必须是一把锁

比较好理解加锁不争夺主存相当于没有锁，解锁不写回相当于没操作，不是一把锁等于没锁。

规定了8种操作

- read-load
- use-assign
- store-write
- lock-unlock

上述操作必须两两组合使用



而Volatile的三种功能：

- 保证内存可见性
- 禁止指令重排序

均应结合JMM进行理解



> 保证内存可见

volatile声明的关键字会被总线嗅探机制监听

当一个线程通过**总线**向主存中写入（store-write）值时，根据MESI缓存一致性总线会将其他线程的工作内存中对应值标记为**失效**，那么其他线程就会去主存中读取新的值

> 不保证原子性

因为volatile是在store-write 上加了锁，而一次整个计算流程以JMM看一共有read-load-use-assign-store-write六步，所以不能保证原子性。（volatile本身只是希望实现修改数据可以及时写入到内存中，且强制其他线程读取新的值）



## i++的问题

i++以JMM来看就很容易知道不是原子性的操作。

那么可以有以下处理方式来实现原子性：

- synchronized
- ReentrantLock
- JUC中的原子类（内部都是CAS实现，直接修改内存）