# Java中的多态

### 面向对象

面向对象最基本的三个特征，**继承、封装和多态**。

1. 封装，合并属性和行为以形成新的数据类型
2. 继承，允许数据类型之间建立某种关系
3. 多态，则是建立关系的具体使用

而Java中的多态又可以分为**静态多态和动态多态**。

### 重载和重写的规则

**重载的规则**

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

**重写和重载的区别**

|          | 重载           | 重写                     |
| -------- | -------------- | ------------------------ |
| 参数列表 | 必须修改       | 不能修改                 |
| 返回类型 | 可以修改       | 不能修改                 |
| 异常     | 可以减少或删除 | 不能抛出新的或更广的异常 |
| 访问     | 可以修改       | 不能做更严格的限制       |



## 多态的实现---分派

### 方法解析

Class文件的编译过程中不包含传统编译中的连接步骤，**一切方法调用在Class文件里面存储的都只是符号引用**，而不是方法在实际运行时内存布局中的入口地址。这个特性给Java带来了更强大的动态扩展能力，使得**可以在类运行期间才能确定某些目标方法的直接引用，称为动态连接**，也有**一部分方法的符号引用在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析**。

静态解析成立的前提是：方法在程序真正执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在编译器进行编译时就必须确定下来，这类方法的调用称为解析。

在Java语言中，符合**“编译器可知，运行期不可变”**这个要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他的版本，因此它们都适合在类加载阶段进行解析。

**解析调用一定是个静态过程**，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成。而**分派调用则可能是静态的也可能是动态的**，根据分派依据的宗量数（方法的调用者和方法的参数统称为方法的宗量）又可分为单分派和多分派。两类分派方式两两组合便构成了四种分派情况：

- 静态单分派
- 静态多分派
- 动态单分派
- 动态多分派

### 静态分派

静态分派多用于重载的实现，重载是在一个类中，存在方法名称相同而参数不同，返回类型可以相同也可以不同的方法。

使用下面的代码解释这个特性

```java
public class StaticDispatch{
    static abstract class Human{}
    static class Man extends Human{}
    static class Woman extends Human{}
    
    public void sayHello(Human guy){
        System.out.println("Hello guy");
    }
    public void sayHello(Man guy){
        System.out.println("Hello man");
    }
    public void sayHello(Woman guy){
        System.out.println("Hello woman");
    }
    
    private static void main(String[] args){
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sc = new StaticDispatch();
        sc.sayHello(man);
        sc.sayHello(woman);
    }
}
```

最终的输出为：

"Hello guy"

"Hello guy"

> Human man = new Man();

实际上，`Human`被称为**静态类型**，而`Man`被称为**实际类型**，也就是man可以重新定义成 `man = new Woman()`，这是在运行时发生的变化。也就是静态类型的变化仅在使用时发生，变量本身的静态类型不变，所以在编译器静态类型是可知的。而实际类型变化的结果在运行期才确定。

所以上述对`sayHello`方法的调用时编译器通过静态类型作为判断依据的结果，编译器无法确定man的实际类型，但静态类型可以确定，所以`man`和`woman`均重载了以其父类为参数的方法。

### 动态分派

动态分派和多态的重写（Override）相关。

```java
private static void main(String[] args){
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
    	woman.sayHello();
    }
```

这段代码的结果比上面**重载**的结果更加显而易见，这就是一段父类引用指向了子对象，并调用实际子对象的方法，显然这不是编译器可以实现的功能，在字节码中，`sayHello()`的调用被替换成了`invokevirtual`指令，这个指令的解析过程大致按

1. 操作数栈的第一个元素的**实际类型**为基准
2. 按该类型去查找 **常量中的描述符**和**简单名称**都相符的方法（方法的描述符在类文件结构中有提及，是对方法 参数，返回类型的描述，这里再加上名称就可以得到一个具体的方法，当然描述符以及简单名称中不包含访问控制），如果可以访问则返回**直接引用**，否则抛出`java.lang.IllegalAccessError`（前面说的访问权限不够）。
3. 按照继承关系向父类查找，未找到抛出`java.lang.AbstractMethodError`

可以看到这个过程，就是一个将编译后的**方法的符号引用**解析成**直接引用**的过程，这也就是方法重写的本质。

### 虚方法表

虚方法表（`Virtual Method Table`）是一种虚拟机中进行**动态分派**解析的一般实现，本质是一个Hash结构，用于方法的符号引用到元数据的查找过程。同样的，对于接口方法也存在**接口方法表**实现`invokeinterface`指令的解析。

如果方法的子类中没有实现该方法，那么子类的虚方法表将存放父类方法的入口地址。

而虚方法表的生成在类加载的连接时进行，在类中变量的初始化完成后将生成**虚方法表**





> ref: 
>
> 《深入理解Java虚拟机》
>
> [Java静态多态和动态多态](https://blog.csdn.net/wisimer/article/details/89574634)

