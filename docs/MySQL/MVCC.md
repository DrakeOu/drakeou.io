# MVCC（总结草稿）

首先我们明确需要讨论的问题，是**多个事务并发情况下如何实现事务的隔离级别**，主要是**读已提交和可重复读**。



MVCC解决事务并发的 `读-写`问题，同时保证性能。

简单来说，我们知道页中的每一行标识数据表中的一行数据，而且每一行中有三个隐藏字段，分别是：

- `row_id`  没有主键时，MySQL会给行增减这个字段，并维持自增
- `trx_id`  事务id
- `roll_pointer`  回滚指针

上面的`trx_id`和`roll_pointer`就是涉及到MVCC的实现方式，其实就是`undo日志`。所以**MVCC的控制功能是基于undo日志实现的**。



## 如何运行

运行的第一点就是事务id（`trx_id`）的创建，但是注意了，MySQL并不会在事务开启时就分配一个事务id，而是当出现第一个写操作时分配（`insert`, `delete`, `update`），同时在进行读操作的时候生成`ReadView`，其中包含如下信息：

- `m_ids` 表示在生成`ReadView`时当前系统中活跃的读写事务的id列表
- `min_trx_id` 生成当前`ReadView`时活跃的最小事务id
- `max_trx_id` 生成`ReadView`时应该给下一个事务分配的id
- `creator_trx_id` 当前事务的id

那么对数据的访问控制就基于上述的参数

- 如果被访问版本的`trx_id`属性值与`ReadView`中的`creator_trx_id`值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值小于`ReadView`中的`min_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`前已经提交，所以该版本可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值大于或等于`ReadView`中的`max_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`后才开启，所以该版本不可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值在`ReadView`的`min_trx_id`和`max_trx_id`之间，那就需要判断一下`trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。

 实际上也很好理解，当前事务id生成时，标识了当前事务的顺序，`m_ids`作为了这条数据的快照，这样事务的连续操作都是基于**这个时刻的快照**，保证访问的一致性。

简单举个例子，A，B两个事务按如下顺序操作：

1. 事务A开启
2. 事务B开启
3. B读
4. A写
5. A提交
6. B读

3和6的读如何保持一致。首先B读时会创建一个`ReadView`快照，此时A未创建事务ID，随后A进行写操作生成事务id并提交。B再读，此时B的`ReadView`快照中，其实A是不在`m_ids`中的，也就是A不是激活事务，但A显然比`max_trx_id`大或等于，表明A的事务在B之后，那么就不可能访问A事务id的数据。

上面的例子也可以换成A先写，B再读，A再写提交，B在读。其实结果当然是一样的，B读取时的`ReadView`中A是作为激活事务存在的，之后的读取中使用同一个快照仍然A是被记录为激活的，不会访问A事务id的记录。

### 小结

如果没有`ReadView`直接根据事务id去判断能否读取是不可行的，因为每次读取的状态变化了（版本链变化了）。而`ReadView`作为快照，保证了在这个事务中读写都将基于**快照生成时的事务状态**，这也就是保证了读取的一致性。

`ReadView`中的几个参数：

- `m_ids` 检查最大最小范围内的激活事务
- `max_trx_id` 判断比当前事务更新的事务，当前事务之后的事务一律不能读取（无论提交）
- `min_trx_id` 判断非激活范围外的事务，一律可以读取，因为全部在当前事务开始前提交
- `creator_trx_id` 用于区分当前事务，保证自己可以读取自己的事务



#### 关于读操作没有事务id

前面说了，只有写操作才会创建事务id，而读操作不会，那么读操作会有判断上导致不一致的问题么？

答案是没有。读操作时当前的事务id是一个默认的0（这点不是很确定），进行当前激活事务的检查可以保证不会读取到未提交的事务，而最大的事务id可以保证不会读到更新的事务，所以功能上是没有问题的。

