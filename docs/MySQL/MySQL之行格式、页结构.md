## MySQL之行格式、页结构



#### 前言

关于为何要了解`MySQL`的物理实现：

> 其实像B+索引，多版本并发控制（MVCC）等MySQL常问的技术知识点都是会对应到具体的物理实现上，如果不了解MySQL到底怎么存储数据，不清楚每个数据行中有什么结构，不清楚B+树中的一个节点对应什么物理结构，又怎么算了解了MySQL



### 从图开始理解

以下面这段创建代码为例：

```mysql
mysql> CREATE TABLE format_demo (
	->		c1 VARCHAR(10),
    ->		c2 VARCHAR NOT NULL,
    ->		c3 CHAR(10),
    ->		c4 VARCHAR(10)
	)
```

那么现在这个表在我们眼中是这样的：(插入了两条数据)

```mysql
mysql> SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)

mysql>
```



对应在磁盘中表又是怎么样存储的呢？

### 行格式

所谓表的构成，实际就是**一行行的数据**，所以在磁盘中表是按行数据进行存储的。那么在磁盘中是一整个表的数据都连续放在一起么？显然不可能，思考数据分页的方法，`MySQL`也是按照**分页**的方式将一个表的数据拆分开存放。以`InnoDB`来说：

- 将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 ***16*** KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

关于**页**的概念先放到这之后再说。

所以现在我们前进了一大步，起码知道磁盘里的表大概长这样：

![磁盘中按页存储的数据](..\static\磁盘中按页存储的数据.png)

再回到**行格式**上，`MySQL`中涉及的有这4种：

1. **COMPACT行格式**
2. **Redundant行格式**
3. **Dynamic行格式**
4. **Compressed行格式**

主要介绍最重要的**COMPACT**格式，首先它长这样：

![COMPACT行格式](..\static\COMPACT行格式.png)

可以看到`MySQL`除了记录用户提供的信息之外还记录了相当的**额外信息**，这些信息可以分为`3`类：

1. **变长字段长度列表**
2. **NULL值列表**
3. **记录头信息**

简要说明这些**额外信息**：

**变长字段长度列表**将**真实数据**中的每个**非空列**按其数据**字节长度**的**逆序**存放起来

![变长字段](..\static\变长字段.png)

空间分配：长度不是固定的，取决于有多少数据



**NULL值列表**中储存了所有没有设置`NOT NULL`的字段（列），并用一个**2进制位**表示该列的`NULL`状态，同时这个列表也是按列顺序的**倒序排列**的，也就是如果该**行数据**中对应第`1`,`3`,`4`个字段可以为空（没有设置`NOT NULL`）那么**NULL值列表**就长这样：

![NULL值列表](..\static\NULL值列表.png)

需要说明的是，`MySQL`中无论是**定长数据**还是**非定长数据**都可以设置对`NULL`的控制，所以如果该列不为空那么**该列数据**的相关信息就存在**变长字段长度列表**中。

空间分配：同时**NULL值列表**是按**整数倍**字节分配空间的，不足的位置补上`0`.

**记录头信息**存储的都是和**行数据控制**相关的内容：

![记录头信息](..\static\记录头信息.jpg)

空间分配：固定`5`个字节`40`个二进制位

每段内容记录信息如下：（不做详细解释了，了解大概即可）

| 名称           | 大小（Bit） | 描述                                                         |
| -------------- | ----------- | ------------------------------------------------------------ |
| 预留位         | 1           | -                                                            |
| 预留位         | 1           | -                                                            |
| `delete_mash`  | 1           | 删除标记位                                                   |
| `min_rec_mask` | 1           | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| `n_owned`      | 4           | 表示当前记录拥有的记录数                                     |
| `heap_no`      | 13          | 表示当前记录在记录堆的位置信息                               |
| `record_type`  | 3           | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶子节点记录，`2`表示最小记录，`3`表示最大记录 |
| `next_record`  | 16          | 表示下一条记录的相对位置                                     |

#### 记录的真实数据

说完记录中的额外信息，那么记录里的真实数据真的只有用户定义的数据么？

显然不是，`MySQL`会自动为每个**行数据**增加一些**额外的列**，例如`DB_ROW_ID`,`DB_TRX_ID`, `DB_ROW_PTR`分别表示数据行的`行id`, `行的事务id`， `指向下一个版本数据行的指针`，其中**事务id**和**指向下一版本的指针**实际都是关系到`MySQL`中**多版本并发控制**的具体实现。

所以到目前为止，我们已经完整了解了**一条数据行**到底长什么样：

![完整的数据行](..\static\完整的数据行.png)

#### 关于定长和非定长类型

**VARCHAR()和CHAR（）**类型的大致区别，在根据建表时设定的**不同字符集下**（字符在字符集中对应占字节`L`），传入类型中的`Maxlen`会限定给`CHAR(Maxlen)`至少分配M*L的空间，而`VARCHAR(Maxlen)`则是完全根据数据具体**字符个数**来计算分配。计算分配的规则不在这里说明。



### 页结构

下面是页结构的示意图：

![页结构长啥样](..\static\页结构长啥样.png)

可以在中间找到我们刚刚讨论的**行数据**位于`User Records`中。

上述内容简述功能如下：

| 名称                 | 中文名             | 占用空间 | 描述                     |
| -------------------- | ------------------ | -------- | ------------------------ |
| `File Header`        | 文件头部           | `38`字节 | 页的一些通用信息         |
| `Page Header`        | 页面头部           | `56`字节 | 数据页专有的一些信息     |
| `Infimum + Supremum` | 最小记录和最大记录 | `26`字节 | 两个虚拟的行记录         |
| `User Records`       | 用户记录           | 不确定   | 实际存储的行记录内容     |
| `Free Space`         | 空闲空间           | 不确定   | 页中尚未使用的空间       |
| `Page Directory`     | 页面目录           | 不确定   | 页中的某些记录的相对位置 |
| `File Trailer`       | 文件尾部           | `8`字节  | 校验页是否完整           |

其中**用户记录**开始是没有的，当插入**行数据**时会使用**空闲空间**，当**空闲空间**装满之后就要申请新的**页**了![页视角数据行的插入](E:\blog\tu\页视角数据行的插入.png)

> 继续说明行记录在页中怎么组织又需要使用到之前提到的行中的头信息

大致如下：

- `heap_no`属性表示当前记录在**页**中的位置，用户插入的数据一般从`2`开始排序，为什么是`2`呢？

  因为 `0`,`1`是**页**中固有的**最大**和**最小行记录**，分别指向**页**最大和最小数据。这里其实涉及到了`MySQL`B+树的物理实现过程，简单来说就是**页**其实就是B+树的一个物理节点，而B+树中所有节点是顺序排列的，这个**排列的顺序**就是按照表的**唯一主键**来进行的（一般会设置一个**与业务无关的逻辑主键**，并且**自增**）。所以这**两个多余的记录**就可以理解成**节点链表中的头尾节点**，用于快速遍历节点。

- `next_record`记录了从**当前记录到下一行数据的地址偏移量**

那么现在**页**中的**行数据**就是这样串起来的：

![包含最大最小的页中行数据](..\static\包含最大最小的页中行数据.png)

这里再提供一个简图说明一个**页是B+树中的一个节点**这句话的意义：

![页和B+树](..\static\页和B+树.png)

### 页目录

> 所以B+树中的索引是怎么在页中实现的呢？这里就涉及到页中另外一个关键的内容：页目录

**页目录就是MySQL在页中可以快速检索数据的保障**。如果没有页目录，那么定位到了一个**页**不就只能顺序遍历一次链表了。当然，**页目录**得以实现的基础也是**行数据**是按主键进行**排序存放**的。

而目录的制作过程大致是这样的：

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的`n_owned`属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近`页`的尾部的地方，这个地方就是所谓的`Page Directory`，也就是`页目录`（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为`槽`（英文名：`Slot`），所以这个页面目录就是由`槽`组成的。

那么最小只有一个分组的概况如下：![仅有一个槽的页目录](..\static\仅有一个槽的页目录.png)

可以观察到最小记录的`n_owned`值为1，而最大记录的`n_owned`值为5。这关系到每个分组是如何设计的：

对于最小记录所在的分组只能有 ***1*** 条记录，最大记录所在的分组拥有的记录条数只能在 ***1~8*** 条之间，剩下的分组中记录的条数范围只能在是 ***4~8*** 条之间。所以分组是按照下边的步骤进行的：

- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 之后每插入一条记录，都会从`页目录`中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的`n_owned`值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在`页目录`中新增一个`槽`来记录这个新增分组中最大的那条记录的偏移量。

所以最终一个有**多个分组**的页面结构就长这样：

![多个槽](..\static\多个槽.png)

#### File Header和File Trailer

不出意料**Header**中保存了这个**页**中的一些信息，而**File Trailer**中保存了指向**下一个页**的指针，用于串联**页面**，也就是B+树。



**全文内容总结自：掘金小册《MySQL是怎样运行的》**