# Redis持久化

Redis运行时数据存在内存中，但机器断电、系统故障后数据就丢失了。因此需要将数据持久化到硬盘中的方法

Redis提供了两种持久化选项：**快照**和**AOF**

相关设置如下：

![持久化设置](../static/redis持久化设置.png)

## 快照持久化(RDB)

Redis可以通过快照去获取某个时间点上的全部数据，以便之后重启使用，或者复制给其他数据库。

根据配置，快照会被存储在指定`dbfilename`的文件中。如果快照文件创建时，系统，Redis或者硬件出现故障会导致这次快照生成失败，那么Redis就丢失了最近一次快照之后的全部数据。

### 快照的使用方式

1. 上图的配置中`save 60 1000`表示如果在60s内发生了超过1000次写入，那么就进行一次快照生成
2. 通过客户端发送`BGSAVE`命令，这会使Redis通过fork去创建一个子进程，在后台进行数据的复制，并将快照写回硬盘。但是子进程的创建是有代价的，内存中的数据越多，子进程的创建就越消耗时间，而且会超过内存空间上限，导致使用虚拟内存，极大影响复制速度。
3. 通过客户端发送`SAVE`命令，这是一个另Redis直接阻塞的命令，Redis不会再响应任何服务，直到快照生成并写入为止。这是一个不常用的指令，但是在极大数据下仍有意义，`BGSAVE`在内存占用过大时，远不如直接暂停一段时间服务进行`SAVE`。
4. 当Redis被`SHOTDOWN`关闭时，会执行一个`SAVE`命令保存内存中的数据
5. 在主从复制的过程中，当从机第一次连上主机时，主机会进行一次`BGSAVE`并将快照发送给从机

## AOF

AOF通过将每次的写命令写入到一个文件末尾来实现数据库信息的记录，但系统故障后，只需要按AOF的顺序将全部指令执行一次就可以复原数据库。

但数据写入到硬盘并不是立即发生的。程序会先将文件写到缓存区中，再等待操作系统将缓存区的数据刷回硬盘，直到刷回硬盘才是真正写到了硬盘中。对于Redis也是同样，如果文件没有写回到硬盘中就不能确保该次AOF操作成功。所以`appendfsync`的设置是基于对文件同步的设置：

- always:	每个redis写操作都将进行同步写入磁盘
- everysec:  每秒进行一次同步，将多个操作同步到磁盘中
- no:  使用这种设置将完全不控制文件的同步，仅凭操作系统来控制刷回磁盘

对于三种设置，结论是`everysec`是兼顾数据安全和性能的最佳选择。因为always要求了每一次写入都要去完成文件同步的操作，考虑redis写多的情况，这种每次同步的方式必然影响服务性能，同时每次都同步也表明了磁盘会长时间进行少量数据的写入，损害极大。而no则完全不控制，写到缓存就当作文件写完了，而实际发生故障时没法直到到底有多少缓存中的文件没有被写入。

## 对比

可以发现**AOF**的方式记录了每一条写操作，即使是一秒一同步也让数据丢失的窗口降低到了1s，而RDB的方式则是丢失了到最近一次快照生成的全部数据，显然RDB丢失的数据更多。但如果**AOF**只有好处就不需要**快照**的保存方式了。

AOF面对的问题也很明显，每次写指令都会被写入，AOF的文件大小是没有上限的，而快照文件的大小可能很稳定，同时在复原数据库时，快照文件直接使用就可以作为数据库启动，而AOF还需要按操作逐个恢复数据，在文件很大时显然很消耗时间。

对于AOF有指令可以优化这些问题，`BGREWRITEAOF`可以开启一个子进程去压缩AOF中冗余的操作。同样也可以通过`auto-aof-rewrite-percentage`和`auto-aof-rewrite-min-size`来控制AOF进行自动压缩 前一个参数表示**相比上一次压缩后体积增大的百分比**，第二个参数表示**AOF文件进行压缩的最小体积**。