# Redis的键过期管理

#### 键的删除策略

- 定时删除
  - 使用定时器，对内存友好，过期的键可以被及时的删除
  - 对CPU不友好，删除过期键这件事情会消耗CPU资源，在内存不是非常紧张的情况下去处理过期键的删除会影响服务器的响应时间以及吞吐量
- 惰性删除
  - 对CPU友好，因为对于过期的键仅在重新尝试取出时才检查过期信息并删除
  - 对内存最不友好，因为内存中会存在非常多过期的键，并且可能用户再也不会主动访问而导致键无法被删除，这甚至是一种**内存泄漏**
- 定期删除
  - 对内存，对CPU理论上均不会有太大压力
  - 每隔一段时间进行删除工作减小了对CPU的负担，避免了惰性导致的内存泄漏

**Redis删除策略**：惰性+定期

惰性删除通过`expireIfNeeded`函数实现，类是一个`filter`对全部的操作指令进行过滤，运行逻辑如下：

![image-20200613114643091](../static/Redis/惰性删除.png)

定期删除通过`activeExpireCycle`实现，运行如下：

![image-20200613115009084](../static/Redis/定期删除.png)

但如果`db.expires`的size小于1表示没有任何键进行了过期记录

#### 持久化时对过期键的处理

加入了过期之后，数据库会随着时间发生变化，所以持久化时需要保存和当时数据库状态一致。

- RDB：运行`SAVE`或`BGSAVE`时，不会将过期的键进行保存，快照的保存是遍历全部的键来保存的，顺带检查过期信息即可。并且通过RBD文件载入数据库时，也是按键进行填入的，过期的键不会被添加到库中。
- AOF：因为AOF实际记录的是写操作记录，所以AOF对于过期键的察觉取决于对数据库的直接操作。如果一个键已经过期但还没有被惰性删除或者定期删除，则AOF文件中不会有任何体现。如果被上述两种删除之后，AOF会显示的添加一条`DEL`语句来表明键因为过期被删除了。AOF重写时则会检查键并对过期的键不予保存。
- 复制：在主服务器键被删除后，会向从服务器发送`DEL`命令，在从服务器未接受到命令并删除之前，从服务器中的键仍然可以正常响应。