# 循环依赖的解决（草稿）

 https://www.cnblogs.com/daimzh/p/13256413.html



1. 什么是循环依赖？

指两个对象A, B 互相有引用，而导致bean创建时递归创建而因两者相互依赖谁也不能创建成功。同样的，多于两个对象的依赖在大的项目中更加常见，且更难以发现。

2. 循环依赖什么时候可以被处理？

Spring仅对单例模式的bean进行了循环依赖的处理，而原型模式将抛出异常

**依赖的方式不全是构造器**



Spring解决循环依赖的方法是三级缓存，分别存放的是：初始化了的实例（一级缓存），提前暴露的实例（二级缓存），实例的工厂方法（三级缓存）。

这里三级缓存中存放的是`ObjectFactory`，这个接口仅用于提供一个返回bean的工程，且一般使用lamda表达式的内部类，区分`FactoryBean`。



### 依赖的解决

之前总结过bean的加载流程，我们知道对bean进行加载时，会在`createBean`中进行创建，而检查依赖并递归创建bean前，会执行下面这段代码

```java
// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
		}
```

第一个关键点为`earlySingletonExposure`，对`bean`是否是单例，是否允许循环引用，以及当前bean是否正在创建进行了检查。而单例表明循环依赖只对单例处理，而循环引用是一个设置值，最后则是一个正在创建过程中bean的缓存，这个值在之前的步骤中会将当前的bean添加到缓存中。所以说只要是单例，这个值就会为`true`。这个值不是发生依赖时才为真，而是单例就为真，这样发生依赖时才可以被正常处理。

而判断中的代码体现了**将ObjectFactory添加到三级缓存**的过程。所以说，bean的创建过程是，

1. 实例化
2. 添加工厂到三级缓存
3. 递归创建依赖
4. 注入属性
5. 初始化

添加缓存是第一步。那么进入到递归B的创建中时，通过`getSingleton`这个方法将获取到`bean`A的工厂方法，用于注入，而完成实例化以及后面的过程，最后继续执行A的实例化以及后面的过程。

而其中B创建时，获取到A的工厂方法后，将其从三级缓存中取出并放入二级缓存中。且A,B创建完成后都将进入到一级缓存中。

![image-20200706133018669](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDcwNjEzMzAxODY2OS5wbmc?x-oss-process=image/format,png)

盗用一下别人的图



bean的创建不是一蹴而就的，需要实例化，之后注入属性，依赖导致问题就出现在实例化的同时必须要求依赖的属性同样实例化，一个强依赖条件的存在将导致创建相互递归形成环路。缓存的意义就在于**破除实例化必须依赖已经完全创建的属性**这个条件，对每个bean都做默认的工厂放入缓存，代替被需要时的bean，从而在依赖bean没有完成创建时可以通过提早曝光的方式，使任何依赖都可以顺利注入（实际上对象未完成创建，但因为引用的关系，最后创建了之后，引用就是一个完整的对象了）。

但这样就会发现一个问题：

**三级缓存在普通循环依赖的情况下，仅仅是提供了一个工厂方法**，且上面的思路来说，二级缓存就足以满足需求，那么三级缓存的意义何在？

### 三级缓存解决AOP中的依赖

二级缓存中存放的是实例化但为完成创建的bean，称为提前暴露的bean

对于需要创建代理类的bean，如果按同样的二级缓存解决循环依赖，那么就意味着这里将必须实例化代理对象了。

为什么这里会需要实现代理对象呢？因为解决依赖的方式就是暴露一个未完成的实例，对于代理需求则对应着一个未完成的代理对象，而循环依赖是通过**悲观的缓存方式**解决的，也就是所有的单例都必须提前实例化且在三级缓存中放入一个工厂方法。那么就意味着代理对象将在此处全部实例化。而这是违反Spring的设计原则的，Spring期望在bean创建的最后阶段进行代理对象的创建，而此时属性未注入，初始化方法未执行，显然不是最后阶段。

所以不是直接在二级缓存中存放实例，而是在三级缓存中存放工厂，那么这样对所有单例对象的强迫实现就是一个工厂，当然普通对象和代理对象修饰的源对象都已经实例化了，而代理对象则可以在真正发生循环依赖时进行创建，并放入到二级缓存中。

也就是增加的一级缓存，使增强的对象，实例化原对象时，仅将工厂提供到三级缓存中，而发生依赖时再破例提前创建代理对象。

### 关于构造器依赖

前面说到，完全的构造器依赖将是无法解决的。因为这将导致在进行第一步时（实例化），就会需求依赖的对象，而依赖对象又会需求回来，此时是没有执行到三级缓存那步的，将无法进行创建。

而**不是完全的构造器参数**是可能解决的。比如A依赖B，为setter方法注入；B依赖A，为构造器注入

这个过程将是

1. 实例化A
2. A加入缓存
3. 创建依赖B
4. 实例化B，A已经实例化可以注入
5. 完成B的创建工作，返回到A的创建
6. 成功注入依赖B
7. 完成A的创建工作。

但如果将上面的A，B对调，将不可以完成构建

B依赖A，为setter方法注入；A依赖B，为构造器注入

1. 实例化A，此时A因为构造器的需求未实例化，没有加入缓存
2. 创建依赖B
3. 实例化B
4. 注入依赖A，但A不在缓存中，去创建A
5. 检查发现A正在被创建，循环依赖

上面这个问题导致的原因是，在一般情况下Spring对Bean的加载是按字母顺序进行的，而先后加载关系将导致不同的结果。