## Zookeeper-ZAB协议与Leader选举

### 为什么需要分布式一致性协议

在讨论ZAB协议即Zookeeper原子消息广播协议前，先讨论一下分布式一致性协议的意义所在。

首先，**任何的一致性协议本身都是为了解决信息同步的问题**，而这个问题不与实际的任何业务逻辑相关，ZAB协议也一样，协议本身并不决定功能，但每个分布式工具都需要一套协议来解决故障时的信息同步以确保系统正常工作以及恢复

### ZAB协议

#### 协议概述

ZAB协议是一种典型的**单主协议**，即同一时间集群中只会有一个主进程进行服务器状态变更的广播，同时在处理并发请求时会存在先后依赖关系，协议同样需要确保全局请求处理的顺序性（绝对的时间顺序）。

#### 协议介绍

协议的运行过程中包含两种模式以及两种角色，分别是**崩溃恢复**， **消息广播**和**Leader**，**Follower**

##### 消息广播

ZAB协议的消息广播过程类似二阶段提交，

>  Leader对客户端请求生成事务**Proposal**，并发送给集群中其他机器，分别收集选票最后进行事务提交

这种方式移除了二阶段的中断逻辑，也就是接收到Follower服务器超过半数ACK之后就进行了提交并广播Follower进行提交，而这样可能导致Leader服务器崩溃后集群内数据不一致：

例如Leader刚刚提交了Proposal之后崩溃了，其他Follower并未收到Commit最后丢弃了这个Proposal，导致恢复后的原Leader存在其他机器不存在的提交日志。同时从这里也可以看出Follower当Proposal出现问题时会进行抛弃，只会写入正确的日志，也就是只要Leader正常工作那么Follower一定写入了该日志，只有Leader会出现多余的日志而Follower只会出现缺少日志需要同步的情况。

##### 崩溃恢复

Leader在进行事务处理时会给每个事务分配一个ZXID

> ZXID是一个64位的数字，低32位自增表示某一个epoch中的事务顺序，高32位用于区分不同的epoch

根据这个ZXID，ZAB协议选择了一种快速且高效的Leader选举方式，拥有最高ZXID的机器成为Leader这样即保证了之前已经提交的全部事务的安全，同时其他机器只需要向前同步即可。

而且因为epoch的存在，恢复的Leader不可能立即再次成为Leader，因为其epoch将落后ZXID不可能为最高。

##### 发现、同步、广播

细分上述两个模式，可以划分成**发现，同步，广播**三个阶段，整个ZK按ZAB协议就在这三个阶段中转换。

1. 发现：

   - Follower给准Leader发送自己已提交最后的Proposal
   - 准Leader接收到过半CEPOCH后，就将epoch+1并广播给Follower
   - Follower接收到广播后反馈ACK给Leader

2. 同步：

   - Leader发送NEWLEADER给Follower确定领导地位
   - Leader按最大的事务广播给Follower进行同步（将Proposal和Commit一起先后广播，直接提交，这里我认为是考虑到**发现**过程中，已经有超过半数的集群参与了Leader选举，超过半数保证集群可用这件事已经被确认了，所以不像正常事务提交那样再进行一次二阶段提交并半数确认）
   - Follower按Proposal和Commit进行提交操作

3. 广播

   本质就是之前叙述的二阶段提交的过程

所以按这三个阶段，Zookeeper集群中的机器都处于如下三种状态之一：

1. **LOOKING**
2. **FOLLOWING**
3. **LEADING**

### Leader选举的源码实现

---To be continue